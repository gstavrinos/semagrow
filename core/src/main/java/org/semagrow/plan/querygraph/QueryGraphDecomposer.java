package org.semagrow.plan.querygraph;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.semagrow.estimator.CardinalityEstimatorResolver;
import org.semagrow.estimator.CostEstimatorResolver;
import org.semagrow.plan.*;
import org.semagrow.selector.SourceSelector;
import org.semagrow.selector.StaticSourceSelector;

import java.util.Optional;

/**
 * Created by angel on 23/6/2016.
 */
public class QueryGraphDecomposer implements QueryDecomposer {



    private org.slf4j.Logger logger =
            org.slf4j.LoggerFactory.getLogger( this.getClass() );

    private final CostEstimatorResolver costEstimator;
    private final SourceSelector sourceSelector;
    private final CardinalityEstimatorResolver cardinalityEstimator;

    public QueryGraphDecomposer(CostEstimatorResolver estimator,
                                CardinalityEstimatorResolver cardinalityEstimator,
                                SourceSelector selector)
    {
        this.costEstimator = estimator;
        this.sourceSelector = selector;
        this.cardinalityEstimator = cardinalityEstimator;
    }

    @Override
    public void decompose(TupleExpr expr, Dataset dataset, BindingSet bindings) {

        /* creates the context of operation of the decomposer.
         * Specifically, collects FILTER statements */
        QueryGraphDecomposerContext ctx = new QueryGraphDecomposerContext( expr );

        SourceSelector staticSelector = new StaticSourceSelector(sourceSelector.getSources(expr, dataset, bindings));
        PlanFactory planFactory = new SimplePlanFactory(costEstimator, cardinalityEstimator);

        /* uses the SourceSelector provided in order to identify the
         * sub-expressions that can be executed at each data source,
         * and annotates with cardinality and selectivity metadata */

        PlanGenerator planGenerator = new QueryGraphPlanGenerator(ctx, staticSelector, planFactory);

        /* optimizes the plans generated by the PlanGenerator */
        DPPlanOptimizer planOptimizer = new DPPlanOptimizer(planGenerator);

        /* selects the optimal plan  */
        Optional<Plan> maybePlan = planOptimizer.getBestPlan(ctx.getQueryGraph().getVertices(), bindings, dataset);

        if (maybePlan.isPresent()) {
            /* grafts the optimal plan into expr */
            if (expr instanceof QueryRoot) {
                ((QueryRoot)expr).getArg().replaceWith(maybePlan.get());
            }
        }
    }

}
