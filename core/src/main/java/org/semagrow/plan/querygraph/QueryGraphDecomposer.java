package org.semagrow.plan.querygraph;

import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.QueryRoot;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.semagrow.estimator.CardinalityEstimatorResolver;
import org.semagrow.estimator.CostEstimatorResolver;
import org.semagrow.plan.*;
import org.semagrow.selector.SourceSelector;
import org.semagrow.selector.StaticSourceSelector;

import java.util.Optional;

/**
 * Created by angel on 23/6/2016.
 */
public class QueryGraphDecomposer implements QueryDecomposer {



    private org.slf4j.Logger logger =
            org.slf4j.LoggerFactory.getLogger( this.getClass() );

    private final CostEstimatorResolver costEstimator;
    private final SourceSelector sourceSelector;
    private final CardinalityEstimatorResolver cardinalityEstimator;

    public QueryGraphDecomposer(CostEstimatorResolver estimator,
                                CardinalityEstimatorResolver cardinalityEstimator,
                                SourceSelector selector)
    {
        this.costEstimator = estimator;
        this.sourceSelector = selector;
        this.cardinalityEstimator = cardinalityEstimator;
    }

    @Override
    public void decompose(TupleExpr expr, Dataset dataset, BindingSet bindings) {

        /* creates the context of operation of the decomposer.
         * Specifically, collects FILTER statements */
        QueryGraphDecomposerContext ctx = new QueryGraphDecomposerContext( expr );

        SourceSelector staticSelector = new StaticSourceSelector(sourceSelector.getSources(expr, dataset, bindings));

        /* uses the SourceSelector provided in order to identify the
         * sub-expressions that can be executed at each data source,
         * and annotates with cardinality and selectivity metadata */

        PlanGenerator planGenerator =
                new QueryGraphPlanGenerator(ctx, staticSelector, costEstimator, cardinalityEstimator);

        /* optimizes the plans generated by the PlanGenerator */
        PlanOptimizer planOptimizer = new DPPlanOptimizer( planGenerator );

        /* selects the optimal plan  */
        Optional<Plan> maybePlan = planOptimizer.getBestPlan( expr, bindings, dataset );

        if (maybePlan.isPresent()) {
            /* grafts the optimal plan into expr */
            QueryRoot e = new QueryRoot(expr);
            logger.info("Plan {}", maybePlan.get());
            e.getArg().replaceWith(maybePlan.get());
        }
    }

    protected QueryGraphDecomposerContext getContext(TupleExpr bgp, Dataset dataset, BindingSet bindings)
    {
        QueryGraphDecomposerContext ctx = new QueryGraphDecomposerContext(bgp);
        return ctx;
    }


}
